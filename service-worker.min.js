import{data,fonts,images,includes,scripts,styles}from"./sw-assets.min.js";const SW_VERSION=202410261520,cacheName="gpizzimenti-app-cache-202410261520",staticFiles=["/sw-registration.min.js","/sw-assets.min.js","/site.webmanifest","/schema.min.json","/index.html",...scripts,...styles,...fonts,...images,...data,...includes],routes=["/"],filesToCache=[...routes,...staticFiles],requestsToRetryWhenOffline=[],IDBConfig={name:"gpizzimenti-app-db",version:SW_VERSION,stores:{requestStore:{name:"gpizzimenti-request-store",keyPath:"timestamp"}}},isOffline=()=>!self.navigator.onLine,isRequestEligibleForRetry=({url:e,method:t})=>["POST","PUT","DELETE"].includes(t)||requestsToRetryWhenOffline.includes(e),createIndexedDB=({name:e,stores:t})=>{const s=self.indexedDB.open(e,1);return new Promise(((e,a)=>{s.onupgradeneeded=e=>{const s=e.target.result;Object.keys(t).forEach((e=>{const{name:a,keyPath:r}=t[e];s.objectStoreNames.contains(a)||s.createObjectStore(a,{keyPath:r})}))},s.onsuccess=()=>e(s.result),s.onerror=()=>a(s.error)}))},getStoreFactory=e=>({name:t},s="readonly")=>new Promise(((a,r)=>{const n=self.indexedDB.open(e,1);n.onsuccess=e=>{const r=n.result.transaction(t,s).objectStore(t),c=new Proxy(r,{get:(e,t)=>"function"==typeof e[t]?(...s)=>new Promise(((a,r)=>{const n=e[t].apply(e,s);n.onsuccess=()=>a(n.result),n.onerror=e=>r(e)})):e[t]});return a(c)},n.onerror=e=>r(n.error)})),openStore=getStoreFactory(IDBConfig.name),serializeHeaders=e=>[...e.entries()].reduce(((e,[t,s])=>({...e,[t]:s})),{}),storeRequest=async({url:e,method:t,body:s,headers:a,mode:r,credentials:n})=>{const c=serializeHeaders(a);try{let a=s;if(s&&s instanceof ReadableStream){const e=s.tee()[0];a=await new Response(e).arrayBuffer()}const i=Date.now(),o=await openStore(IDBConfig.stores.requestStore,"readwrite");await o.add({timestamp:i,url:e,method:t,...a&&{body:a},headers:c,mode:r,credentials:n}),"sync"in self.registration&&await self.registration.sync.register("retry-request")}catch(e){}},getCacheStorageNames=async()=>{const e=await caches.keys()||[],t=e.filter((e=>!e.includes(cacheName)));return{latestCacheName:e.find((e=>e.includes(cacheName))),outdatedCacheNames:t}},updateLastCache=async()=>{const{latestCacheName:e,outdatedCacheNames:t}=await getCacheStorageNames();if(!e||!t?.length)return null;const s=await caches.open(e),a=(await(s?.keys()))?.map((e=>e.url))||[];for(const e of t){const t=await caches.open(e);for(const e of a){const a=await s.match(e);await t.put(e,a.clone())}}},getRequests=async()=>{try{const e=await openStore(IDBConfig.stores.requestStore,"readwrite");return await e.getAll()}catch(e){return e}},retryRequests=async()=>{const e=await getRequests(),t=e.map((({url:e,method:t,headers:s,body:a,mode:r,credentials:n})=>{const c=new Headers(s);return fetch(e,{method:t,headers:c,body:a,mode:r,credentials:n})})),s=await Promise.allSettled(t),a=await openStore(IDBConfig.stores.requestStore,"readwrite"),{keyPath:r}=IDBConfig.stores.requestStore;s.forEach(((t,s)=>{const n=e[s][r];"fulfilled"===t.status&&a.delete(n)}))},installHandler=e=>{e.waitUntil(caches.open(cacheName).then((e=>Promise.all([e.addAll(filesToCache.map((e=>new Request(e,{cache:"no-cache"})))),createIndexedDB(IDBConfig)]))).catch((e=>{})))},activateHandler=e=>{e.waitUntil(caches.keys().then((e=>Promise.all(e.filter((e=>e!==cacheName)).map((e=>caches.delete(e)))))))},cleanRedirect=async e=>{const t=e.clone(),{headers:s,status:a,statusText:r}=t;return new Response(t.body,{headers:s,status:a,statusText:r})},fetchHandler=async e=>{const{request:t}=e;e.respondWith((async()=>{try{if(!self.navigator.onLine&&isRequestEligibleForRetry(t))return await storeRequest(t),await caches.match("/offline.html");const s=await caches.match(t,{ignoreVary:!0,ignoreSearch:!0});if(s)return s.redirected?cleanRedirect(s):s;const a=await fetch(e.request);if(a)return a}catch(e){return await caches.match("/offline.html")}})())},messageHandler=async({data:e})=>{const{type:t}=e;switch(t){case"SKIP_WAITING":(await self.clients.matchAll({includeUncontrolled:!0})).length<2&&(await self.skipWaiting(),await self.clients.claim());break;case"PREPARE_CACHES_FOR_UPDATE":await updateLastCache();break;case"retry-requests":"sync"in self.registration||await retryRequests();break}},syncHandler=async e=>{const{tag:t}=e;switch(t){case"retry-request":e.waitUntil(retryRequests());break}};self.addEventListener("install",installHandler),self.addEventListener("activate",activateHandler),self.addEventListener("fetch",fetchHandler),self.addEventListener("message",messageHandler),self.addEventListener("sync",syncHandler);