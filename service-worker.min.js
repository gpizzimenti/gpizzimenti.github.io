import{data,fonts,images,includes,scripts,styles}from"./sw-assets.min.js";const SW_VERSION=202410201830,cacheName="gpizzimenti-app-cache-202410201830",staticFiles=["/sw-registration.min.js","/sw-assets.min.js","/index.html",...scripts,...styles,...fonts,...images,...data,...includes],routes=["/"],filesToCache=[...routes,...staticFiles],requestsToRetryWhenOffline=[],IDBConfig={name:"gpizzimenti-app-db",version:SW_VERSION,stores:{requestStore:{name:"gpizzimenti-request-store",keyPath:"timestamp"}}},isOffline=()=>!self.navigator.onLine,isRequestEligibleForRetry=({url:e,method:t})=>["POST","PUT","DELETE"].includes(t)||requestsToRetryWhenOffline.includes(e),createIndexedDB=({name:e,stores:t})=>{const a=self.indexedDB.open(e,1);return new Promise(((e,s)=>{a.onupgradeneeded=e=>{const a=e.target.result;Object.keys(t).forEach((e=>{const{name:s,keyPath:r}=t[e];a.objectStoreNames.contains(s)||a.createObjectStore(s,{keyPath:r})}))},a.onsuccess=()=>e(a.result),a.onerror=()=>s(a.error)}))},getStoreFactory=e=>({name:t},a="readonly")=>new Promise(((s,r)=>{const n=self.indexedDB.open(e,1);n.onsuccess=e=>{const r=n.result.transaction(t,a).objectStore(t),c=new Proxy(r,{get:(e,t)=>"function"==typeof e[t]?(...a)=>new Promise(((s,r)=>{const n=e[t].apply(e,a);n.onsuccess=()=>s(n.result),n.onerror=e=>r(e)})):e[t]});return s(c)},n.onerror=e=>r(n.error)})),openStore=getStoreFactory(IDBConfig.name),serializeHeaders=e=>[...e.entries()].reduce(((e,[t,a])=>({...e,[t]:a})),{}),storeRequest=async({url:e,method:t,body:a,headers:s,mode:r,credentials:n})=>{const c=serializeHeaders(s);try{let s=a;if(a&&a instanceof ReadableStream){const e=a.tee()[0];s=await new Response(e).arrayBuffer()}const i=Date.now(),o=await openStore(IDBConfig.stores.requestStore,"readwrite");await o.add({timestamp:i,url:e,method:t,...s&&{body:s},headers:c,mode:r,credentials:n}),"sync"in self.registration&&await self.registration.sync.register("retry-request")}catch(e){}},getCacheStorageNames=async()=>{const e=await caches.keys()||[],t=e.filter((e=>!e.includes(cacheName)));return{latestCacheName:e.find((e=>e.includes(cacheName))),outdatedCacheNames:t}},updateLastCache=async()=>{const{latestCacheName:e,outdatedCacheNames:t}=await getCacheStorageNames();if(!e||!t?.length)return null;const a=await caches.open(e),s=(await(a?.keys()))?.map((e=>e.url))||[];for(const e of t){const t=await caches.open(e);for(const e of s){const s=await a.match(e);await t.put(e,s.clone())}}},getRequests=async()=>{try{const e=await openStore(IDBConfig.stores.requestStore,"readwrite");return await e.getAll()}catch(e){return e}},retryRequests=async()=>{const e=await getRequests(),t=e.map((({url:e,method:t,headers:a,body:s,mode:r,credentials:n})=>{const c=new Headers(a);return fetch(e,{method:t,headers:c,body:s,mode:r,credentials:n})})),a=await Promise.allSettled(t),s=await openStore(IDBConfig.stores.requestStore,"readwrite"),{keyPath:r}=IDBConfig.stores.requestStore;a.forEach(((t,a)=>{const n=e[a][r];"fulfilled"===t.status&&s.delete(n)}))},installHandler=e=>{e.waitUntil(caches.open(cacheName).then((e=>Promise.all([e.addAll(filesToCache.map((e=>new Request(e,{cache:"no-cache"})))),createIndexedDB(IDBConfig)]))).catch((e=>{})))},activateHandler=e=>{e.waitUntil(caches.keys().then((e=>Promise.all(e.filter((e=>e!==cacheName)).map((e=>caches.delete(e)))))))},cleanRedirect=async e=>{const t=e.clone(),{headers:a,status:s,statusText:r}=t;return new Response(t.body,{headers:a,status:s,statusText:r})},fetchHandler=async e=>{const{request:t}=e;e.respondWith((async()=>{try{if(!self.navigator.onLine&&isRequestEligibleForRetry(t))return await storeRequest(t),await caches.match("/offline.html");const a=await caches.match(t,{ignoreVary:!0,ignoreSearch:!0});if(a)return a.redirected?cleanRedirect(a):a;const s=await fetch(e.request);if(s)return s}catch(e){return await caches.match("/offline.html")}})())},messageHandler=async({data:e})=>{const{type:t}=e;switch(t){case"SKIP_WAITING":(await self.clients.matchAll({includeUncontrolled:!0})).length<2&&(await self.skipWaiting(),await self.clients.claim());break;case"PREPARE_CACHES_FOR_UPDATE":await updateLastCache();break;case"retry-requests":"sync"in self.registration||await retryRequests();break}},syncHandler=async e=>{const{tag:t}=e;switch(t){case"retry-request":e.waitUntil(retryRequests());break}};self.addEventListener("install",installHandler),self.addEventListener("activate",activateHandler),self.addEventListener("fetch",fetchHandler),self.addEventListener("message",messageHandler),self.addEventListener("sync",syncHandler);